<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>stateOfIt</title>
  </head>
  <body>state of the system<br>
    <br>
    <ol>
      <li>the database engine in use was known for being unreliable. Using it was a bad idea from the beginning. It was easier to
        configure than competitors, but there was a reason for that- you don't have to configure the parts that are missing but
        needed for reliability.</li>
      <li>the database engine does not support the 3rd most important feature/reason for using a database: rigorous maintenance of
        relationships between data in different tables (first two are: metadata directed storage for large quantities of data,
        indexing for rapid access.)</li>
      <li>the database has been manually partitioned due to both arbitrary limit on number of columns per table (the usage here is
        about 20 times more columns than the high end of common) and for ease in moving a quarter's worth of data around. The
        technique involved violates the integrity of the database, but sure is convenient.</li>
      <li>this unreliability, aggravated by bad use, is likely the stimulus for the quarterly rebuild, which being casually
        synchronized with quarterly data dumps may have masked how broken the architecture is</li>
      <li>Every time that 'database build' is run out of cycle is an indication of a break.</li>
      <li>The lack of proper foreign key implementation has led to tables being architected as views. That entails data duplication
        which leads to bugs due to divergence of the duplicated data. This latter was presently evidenced as I chose the rebuild
        dmgr data for pricing and there were many errors, using what is supposedly a derived copy of that dmgr data 'fixed' the
        pricing.</li>
      <li>The view-styled table layout precludes good indexing, and mysql has a limit on the number of indexes on a table. Proper
        data layout would allow for 100% indexing of RCON's such that all searches would take the same amount of time, and be much
        faster than at present.</li>
      <li>Partitioning by quarters results in having to "union" the data back together for multi-quarter queries. That brings you up
        to some of the arbitrary limits that mysql has. It also means that any maintenance task is 40 times more difficult. </li>
    </ol>
    <p>source code</p>
    <ol>
      <li>five different programming languages are used. Everyone of them talks to the database. There is no excuse for that, it is
        irresponsible. </li>
      <ol>
        <li>the database build is done in C++</li>
        <li>the server is done in java</li>
        <li>the data import is done in C# (with minor legitimacy)</li>
        <li>the client is done in PHP</li>
        <li>a few daily operations are in SQL<br>
          Having all these different languages means that you must duplicate that many times over the business rules of the system.</li>
      </ol>
      <li>all of the database operations eventual produce SQL, in order to provide some portability to other database engines. Even
        when an operation is best done in some convoluted sql expression such can still be launched from one of the other 4
        languages which are capable of implementing the rules for <strong>when</strong> that sql chunk should be run. Each such chunk
        is usually tied to a table, and should be embedded in the 'real code' for that table for ready maintenance.</li>
      <li>The only C++ program is the 'database build'. That the database build has to be run by its author tells you the software
        involved was never completed. CW cannot tell me what he does other than invoke the program. The program itself seems fairly
        simple, perhaps an indication of incompleteness.It also might as well have been written in some scripting language, it takes
        no advantage of any of the special features that justify using C++. C++ is an expert's language, best suited for writing
        other languages or when you need every bit of speed a system is capable of. I (Andy) enjoy C++ but would never use it for a
        task such as fedfis. </li>
      <li>the gov't provided some C# example code. That could have been used to generate a simple rendering of the data that then
        would be picked up by code written in our primary language for actual import into our working databases. Instead it
        duplicates parts of our server stuff meaning that business logic is implemented potentially differently there.</li>
      <li>the gui is done in php. That is overkill for the simplisitic gui you have but apparently was an easy way to use the 3rd
        party grid. Javascript is a better choice these days, I think Jeff already was planning on the switch/ What is bad about the
        php implementation is that it has intimate knowledge of the database instead of no knowledge of it. In a few cases it goes
        around the server to touch some tables. The going around the server is done for diagnostics, but is actually quite time
        consuming. The server itself could have been instrumented for this but I gather the state of the server code is such that
        Jeff didn't want to touch it.</li>
      <li>The server is done in Java. </li>
      <ol>
        <li>The authors ignored some of the prime programming techniques used for writing reliable easy to maintain code. There are
          200k lines of code for a 30 to 50k sized problem. Such verbosity is due to lack of encapsulation which in turn makes it
          hard to change anything. For instance: there are 150 locations that connect to some database, in reality there are only 3
          distinct connections and it is nice to have that clear without digging into details.</li>
        <li>A technique for integrating modules from independent vendors is in play, despite all the code being in house. It allows
          many different vintages of the server code to be running, a different vintage for each institution type. The desire for
          that is understandable, however good programming practices make that unnecessary. A bug for one institution type is more
          likely than not a bug for the others.<br>
          This allows you to patch something for one inst type without testing the effect on others, good clean modularity prevents
          such concerns in the first place. <br>
          There was a better way to do this, using RMI turns part of the system into a black box, and is lower performance.</li>
        <li>The authors are not adept programmers. Just flipping through the code I have found bugs. They worked around the bugs
          rather than applying a simple and obvious fix. </li>
        <li>It has been limited to java 4, V5 was a major improvement and has been production worthy since around 2004. Failure to
          take advantage of it leaves the code verbose and harder to maintain on a line-by-line basis. Subsequent versions prior to
          8 weren't as big a deal, except for scads of bug fixes and security fixes. V4 vs V8 is like talking to a toddler vs
          talking to a teenager. (C++ is like talking to a philosopher, and python is like talking pidgin with a south seas
          islander)</li>
        <li>Hungarian notation is used for variables names. That is the signature of an inept programmer. You shouldn't ever need to
          be reminded of the type of a variable, that is the compiler's business not yours. The technique is named 'Hungarian' not
          due to any relationship to the country or culture but rather because it makes names unpronounceable, like the Hungarian
          language appear to us Indo-Eureopean speakers.</li>
        <li>A fancy technique for choosing data dependent behavior is used that confounds analysis of the program. Every case I have
          investigated could have been done more simply with standard coding practices.</li>
      </ol>
      <li>The source code was never properly put into a revision management system. There was a non-web VCS running on one of the
        servers. Jeff has started putting stuff into a web based one (good for disaster recovery) but used it in an antagonistic
        fashion. As such there is a fair degree of uncertainty as to what is actually executing on each server, and what is
        nominally the same program has 6 different versions in service.</li>
      <li>summary: Changing the architecture involves making changes in 5 different pools of code when it could have been
        beneficially constrained to 2, one of which can be embedded in the other. The same logic is partially implemented in
        multiple places and multiple languages. </li>
      <li><br>
      </li>
    </ol>
    <p><br>
    </p>
  </body>
</html>
