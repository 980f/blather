<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>AndyHeilveilCV4FedFIs</title>
    <meta content="Andy Heilveil" name="author">
  </head>
  <body>
    <li>Hello Jeff. <br>
      <br>
      I am going to give you some extended answers to your questions as much to give you an idea of me as of my skills.<br>
      <br>
      IT Recruiting Questions:
      <h4>How could you see yourself best utilized to help out FedFis?&nbsp; </h4>
      <ol>
        <li>Taking pressure off the lead designer so that he can design more and code less.&nbsp;</li>
        <li>I have experience directly interacting with customers, including highly irate ones. I am good enough at that to have been invited to the customer's home for
          dinner with the family.</li>
        <li>I don't need to nor desire to work full time, although I can when there is an urgent need for it. That should ease scheduling, you would have me on-demand
          rather than having to make efficient use of prepaid time.</li>
        <li>I enjoy infrastructure work, making and embellishing frameworks to simplify the job of the application coder so they can focus on functionality while I take
          care of making the system run well.</li>
      </ol>
      <h4>...What are your non-executive IT skill sets?</h4>
    </li>
    <li>I am not sure what you mean by 'non-executive IT skill sets'. <br>
      If that includes release management then I have at least one such skill, I am not happy with delivering a product that hasn't been built hands-free with no input
      other than a release tag. That is especially important when you are rushing out a patch. </li>
    <li>I have done customer training on systems that I have designed. </li>
    <li>I have worked as a translator between programmers and management, and between sales people and technicians.</li>
    <li>While doing development I maintain an as-built specification, that has been readily transformed into the product's manual. I put my working notes into a wiki
      (Redmine), readily findable by the next engineer to work on the project. <br>
      <ol>
      </ol>
      <h4>What languages do you code? Rate your ability on a scale from 1 to 10 for&nbsp;each language. &nbsp;if Java, up to what version? <br>
        (We use PHP, Java, some C-sharp) </h4>
      For java my last significant work experience was with 1.5. In footnotes I discuss an ORM I wrote in Java. <br>
      <br>
      I haven't worked with enough Java coders to have a basis for ranking myself, but generally produce far less lines of code to get a job done than do others based
      on what I saw at Netspend. E.G. When I took over from a contractor that was billing for a "moderately experienced Java programmer" I produced code that actually
      worked and was 1/17th the size of what the contractor had done. That was my first Java program and I did in 70 hours what the 'moderately experienced' person
      could not get done in 500. I suspect that was as much invalid billing on their part rather than superior skills on my part, the coder was forced to do some stupid
      things by his manager. </li>
    <li><br>
    </li>
    <li>There is a package for java I've used that is similar to what I know of PHP, see <a href="https://velocity.apache.org">velocity.apache.org</a>. (That project
      has halted development but is still in use.)<br>
      <br>
      My C++ skill is fairly extensive, although perhaps not expert. I can point you to a github repo where I've been repackaging code I did for my last employer into a
      publicly sharable library. I've done things like an L10n system that doesn't require wrapping each item to translate in a macro call, I used varargs templating to
      use type info to identify items to translate during the rendering the equivalent of Java's Message.format() function. I once took over code from a PhD former
      college professor of CS which had things in it like an INI file reader which opened and closed the file for each item read from it. It took minutes to load data.
      I replaced that with a module that read the file in one gulp and parsed it into a data structure that could then be scanned in what took a fraction of a second.
      The STL is a minefield of IMHO gratuitous exceptions- I wrap its use with classes that deal with pointless exceptions (treat a null string as an empty one), and
      simplify syntax (java style iteration instead of STL 'begin' and 'end' iterators, one of many things that java does better than C++).<br>
      <br>
    </li>
    <li>My experience in assembly coding microcontrollers and microcoding CPU's is not likely to be directly relevant, but does give me an awareness of what is actually
      executing on the hardware for the code that is being written at high level. </li>
    <li><br>
    </li>
    <li>Independent of language it is rare that I have let a significant bug get out into the field. In 4 years of one product we had less than one patch release per
      year, with about 3 feature releases. I did not have the resources to do any unit or regression testing, the only testing was to have the customer support
      personnel bang away at systems. My main tool to achieve low defect rates is to highly factor code and highly reuse it, very few lines of code were hidden in
      rarely accessed corners.<br>
      <br>
      I did development on one C# program, for a WinCE 3.0 system. I was tasked with writing a nominal device driver in C++ then writing code to deal with the data
      coming from that device driver. I found C# to have minor improvements over Java, but haven't invested the time to learn it as I dislike the Windows operating
      environment and as such stick to portable code bases (meaning C++ and Java). At a place I worked at for a short while in 2005 they were replacing their C# with
      java, they were using an enterprise server written in java and had duplicated a bunch of effort using C# to build a call center interface into that system. <br>
      <br>
      I am learning a new JVM language named Kotlin. Among its more interesting features is that it can be compiled into both JVM bytecode and javascript source. The
      latter is still somewhat experimental. Kotlin is open source and comes from the developers of the current Android Studio. It has the more interesting features of
      C# (delegates, properties), it calls and can be called from Java without veneers or other tomfoolery, it has lambda's even though it only uses Java 1.6 byte
      codes, and it has a diabetes-generating amount of syntactic sugar to coat the more verbose aspects of Java (hopefully neither you nor a loved one is diabetic). It
      has what it calls 'string interpolation' which is similar to PHP (the company produces a product <a href="https://www.jetbrains.com/phpstorm/">PHP Storm</a>).
      Kotlin also can be converted into java, should one decide that in the end it isn't as good as it seems.<br>
      <h4><br>
        What is your skill level writing&nbsp;SQL? Stored procedures? &nbsp;Have you ever done DBA work? What RDBMS? ( We use MySQL ).</h4>
      I only directly wrote SQL at one job. Much of what I was tasked with was replacing queries that were very slow with ones that were fast. The DB engine was Oracle
      9, which had a mechanism for overriding the query planner, I had to twist its arm pretty hard on some of the queries. <br>
      Oftentimes I was replacing queries written via an ORM system with handwritten SQL in order to achieve the speedups.<br>
      A few times I did the reverse- transforming some amazingly gnarly SQL into Java code using the ORM to do the queries. I found bugs in the SQL despite it using SQL
      features I never saw before, or since.<br>
      I try to avoid writing SQL "by hand". I've used two variations on ORM mappers, and when one wasn't available I used an SQLStringBuilder class I wrote to ensure
      all punctuation was correct, and to prevent sql injection attacks via quoting and prepared statements.<br>
      I do know the difference between inner joins and outer joins and know what a correlated sub-query is.<br>
      <br>
      The few stored procedures I wrote fall into two categories: triggers to maintain backward compatibility for old queries after a schema change, and code to
      generate a database for regression testing applications. The latter one gave me a greater appreciation for properly normalized schemas, such as the consequences
      of things like having two tables with foreign key constraints into each other.<br>
      <br>
      I haven't done DBA work as a job duty. I have operated a keyboard while the real DBA told me what to do over the phone from some vacation paradise. That database
      was Postgres. <br>
      Instead I have written code to perform most of the DBA functions our product needed, no humans involved.&nbsp; The database involved was HSQLDB (aka Hypersonic),
      which I used embedded rather than as client-server. Part of the DBA trickery was recognizing times when the humans would be looking elsewhere to do things like
      database compaction (Postgres calls this VACUUM).</li>
    <h4>Thoughts / experience w/ NoSQL? if any experience, which platforms? </h4>
    No experience, but a handful of thoughts:
    <ul>
      <li>Some NoSQL systems use an RDBMS to store the data, I'm guessing the query mechanism of NoSQL has handy query features but built-for-the-purpose storage
        engines aren't mature.</li>
      <li>If you don't need referential integrity then your data is pretty simple, or dangerously redundant.</li>
      <li>When an RDBMS becomes part of an application it seems that the app implementation becomes a slave to the DBMS, I wonder if NoSQL systems also have a tendency
        to kick back hard into the application coding.</li>
    </ul>
    <h4>Have you ever setup PCS (installed Windows 7 or newer), and or installed/administered virtual machines? Any experience with VMware vSphere?</h4>
    <ol>
      <li>I've used VM's but not maintained any for production use.</li>
      <li>I once managed to get a VM to use a pre-existing hard drive in place, haven't managed to pull that trick off for a few years now.</li>
      <li>The last Windows I installed on a regular basis was windows XP, which I did on a very regular basis (that's a dig at Microsoft). <br>
        I am a linux user, for home as well as work. The short stint I did with a Vista system was painful, as soon as I could I installed linux with Windows in a VM
        for the only application I used that required it. </li>
    </ol>
    <h4>Any Dev-ops / AWS experience? </h4>
    Nope. When I read articles on Dev-ops I wonder what the people are comparing it to. I have engineered projects which had software as a major component, rather than
    software being the whole of the product. I do have an anecdote that might pertain: A coworker of mine on a seismic data display workstation quit and took a job as
    phone support for Shell or somesuch oil exploration company. He started writing little apps to help out the customers. Management found out about it and gave him a
    staff of 4 traditional programmers to make a new product. That staff came up with a 6 month development plan with all sorts of documents to be generated and finally
    code to be written. My friend felt that there were a number of untested dependencies that should be experimented on before settling in on such a plan. They
    disagreed. He wrote enough of the application their way over a weekend and showed them a killer flaw in their assumptions. <br>
    <br>
    I had a similar experience in the personal computer design group at T.I. Microsoft had issued a spec on how mice and other pointing devices were to be interfaced.
    The software designer in a planning meeting estimated it would take 3 months to implement. During a break I told my tech what the requirements were. At the lunch
    break I brought the software designer to my lab and showed him a working and functionally complete version of his 3 month project. The designer presumed that the
    task had to be done in assembler and that despite have a graphics technology research department working in the cubicle next to his that it had to be done from
    scratch. <br>
    <br>
    My anecdotes are meant to show the attitude that for software to be developed rapidly one first creates the tools (i.e. libraries) that make it easy to describe the
    task. At paymate I took code written by the networking expert and factored it into pieces such that a task that took about a month the first time took only a few
    days the last time. <br>
    <br>
    <h4>Any Wordpress development experience? </h4>
    Nope. I do have friends who moan about it on facebook but haven't had the pleasure of firsthand experience with it.&nbsp;
    <h4>Any Full stack development experience? If no, then any Front end or backend? &nbsp;what technologies? (Swing, Angular, NodeJS, etc) </h4>
    Probably not any you would find relevant, the last was in 2005. At one company I was responsible primarily for the network of client computers (headless linux boxes
    spread across the US). The server shared code with the client (perhaps 30% by l.o.c.) and so as time went on I did server work as well (had to test how my changes
    affected the server). Since we had a very focussed system we used a platform called Jetty to do the http stuff, instead of something like apache or any other web
    service framework. I did do some development at a place that used Tomcat, I did not find it well documented. <br>
    The system I mention here and elsewhere was a credit card acquisition system. I did the terminal programming, and helped the guy doing server programming. He would
    write straight-line code to handle a new task, I would factor the code and add edge case detection. He would write handlers for the edge cases and we both worked on
    automating regression testing. We had an apache server on our test and development machine, but on the production system found that mating our code to a servlet
    adaptor to apache added complexity and did not provide an identifiable benefit.<br>
    If you have just one task to do sometimes a general purpose framework is an impediment rather than an aid.<br>
    <hr>
    <h3>Footnotes</h3>
    <h3> </h3>
    <h4>ORM in java</h4>
    <p>For an analytical instrument I wrote an ORM that mated the Java data to a revisioning (as in change tracking) database, there was a requirement to not alter
      records, to change a value you create a new record with the altered data that includes a reference to the record it nominally replaced. <br>
      The ORM also automated DBA activities: upon program startup the database schema was read to create an object representation of the database, another instance of a
      schema representation was made from the program logic. The two schema representations were compared and appropriate ALTER TABLE commands issued. I was a bit of a
      chicken and deletes only removed referential integrity, the columns were left in place, which was handy when rolling back a program update. <br>
      The SQL to store and retrieve objects was generated by the ORM, no manually written SQL appeared anywhere in the system. There was never a need for ad-hoc queries
      in the product, and since the application and the database engine ran on the same processor there was nothing to be gained by doing fancy joins on the database
      side of the connection. <br>
      Part of my ORM implementation provided change detection, each object had a backing store of the values last read from the database, at various opportune moments
      objects were inspected for changes and the database updated with new values. That compare operation was used to highlight the <code>SAVE</code> button, but also
      to limit disk activity. <br>
      <br>
    </p>
    <h4> Event driven programming</h4>
    <p> My last big project was done in C++ on an embedded linux system, using GTK as the GUI interface. A significant part of the application was in effect a dedicated
      spread-sheet: the user configured measurement of a set of chemical elements, entered calibration data and configured reports (within a narrow set of options). Any
      change to the calibration data or data acquisition required a recalculation of derived data and redrawing of any screens inspecting that data. The data was
      implemented by a class hierarchy of template-based wrappers around a document-object representation. The document objects could be read and written to JSON files,
      written to csv files, and the GUI was mostly built via code given the data storage keys and a root node of the stored data. In order to update dependent data and
      GUI's I overloaded <code>operator =</code> and detected changes of values and upon change executed a list of callbacks. Most of those callbacks were attached by
      constructor code of the containing objects. There was even a touch of referential integrity involved, some data was correlated to other data and creation and
      deletion of related objects was automated via a single line of code mentioning the relationship (create or delete a primary object and dependent objects were
      created or deleted without additional coding).<br>
      That facility (persistence class with cheap reflection) was so handy we started using it for event-driven logic that didn't involve stored data or GUI generation.
    </p>
    <h4>Model-View-Controller</h4>
    <p>Or <i>reinventing every wheel twice</i>. The MVC tooling I've seen all lends itself to creating rigid GUI's, that adapt poorly to different sized screens and
      tend to mask the internal workings of the system the GUI is the face of. MFC was the worst in using a list of integers to mate view to model, without ensuring
      that the integers were unique. Humans should not have to manually manage lists of abstract numbers. Android standard development is to generate a screen using a
      tool that emits an XML description of a view. Then one has to duplicate much of that by making manually maintained references into the xml to, for example,
      connect a button to the action for it. Qtcreator does much the same.<br>
      <br>
      People make a mental model of the inner workings of a system. They base their model on what they can see. If the GUI View does not closely reflect the Model's
      data relationships then the user may create a model that is a poor match to the real one. When that happens you get support issues with people wondering why doing
      what seems obvious to them doesn't get the desired response from the system.</p>
    <p> As such I have, as much as practical, generated GUI's at run time via reflection on the data model, with a little bit of manual assistance to keep from
      over-engineering the generator code. An example of the latter is that sometimes a structure is flattened into a single view so that the user doesn't have to
      navigate a tree widget to get a comprehensive picture of the data. Sometimes an array is best viewed as a table, sometimes it is better as a tabbed dialog. <br>
      <br>
      <br>
    </p>
    <ol>
    </ol>
  </body>
</html>
