<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>spectrumsquish</title>
  </head>
  <body>
    <h2>Spectrum squish</h2>
    <h3>A non-lossy data compression algorithm <br>
      first targeted at XRF spectra.</h3>
    It is common for XRF spectra to consist of many narrow nearly Gaussian peaks over a gentle hump of background. A 24 bit dynamic range for peak height is common, taking 3 bytes per channel of data. Of those 3 bytes the most significant byte is zero for large subsets of the spectra, the upper 2 bytes both zero for an also large part of the spectrum. <br>
    When doing rapid analyses the maximum channel count is often quite a bit less than what the channel memory can accommodate, the upper byte can be entirely ignored as always being zero.<br>
    In order to reduce transmission time (and perhaps storage space but that has become moot in the epoch of terabyte flash drives!) we wish to not bother to send most significant zero bits. <br>
    <br>
    The present scheme is similar to an old seismic data acquisition format used at my first employer, where the amplifier gain was stepped up during acquisition and the gain setting stored along with the digitized value of the amplifier output. This is very similar to floating point formats in computer math, the gain is the exponent, the digitized output the mantissa. We deviate from this floating point format by only showing the exponent when it changes.<br>
    <br>
    This encoding has the concept of&nbsp; "present field width" and the bit stream is parsed into words of that size. If the parsed word is all ones then it is not data but is followed by a new field width value. <br>
    Data values are absolute amplitude, the 'field width' is 1:1 with "number of most significant bits that are zero in the following data".<br>
    <br>
    The number of bits in the field width selector may be encoded in different ways, in this write up we will use a fixed 4 bit field as the data set of interest is short count time spectra which rarely have more than 1000 counts in a channel. <br>
    <br>
    <hr>
    <h3>Defining the format by the parser's algorithm</h3>
    The initial state of the parser is "expect field width".<br>
    When 'expecting field width' a 4bit field is pulled from the bit-stream, 0 being replaced with the raw data size, and then saved as "present field width".<br>
    When parsing channels:<br>
    A field of "present field width" bits is pulled from the bit-stream, if it is all ones then we enter "expect field width" state else we zero-extend it save it to the output word stream.<br>
    <hr>
    <h3> Encoding is where the difficulty lies</h3>
    Changing the exponent has a cost of 'present field width' bits plus size of width code. Changing to a larger field width is necessary to not truncate data, but we then have to wonder whether we should reduce it back down or keep it to the larger number for a while.<br>
    If we bump up one bit then every successive field that could have a smaller exponent has a wasted bit. When the number of those wasted bits equals the cost of a size change code then we would have been better off reducing the field width.<br>
    While there is input data:<br>
    <ol>
      <li>look ahead read input field.</li>
      <li>if greater than max allowed by present field width then</li>
      <ol>
        <li>translate input to output until input pointer equals one behind lookahead pointer.</li>
        <li>compute field width that can encode the value.</li>
        <li>emit field change</li>
        <li>reset lookahead state tracking</li>
      </ol>
      <li>if less than half of present max field width (msb is zero) then </li>
      <ol>
        <li>increment "potential savings".##track smallest step down and multiply by that to get better estimate of potential savings.</li>
        <li>if potential savings &gt; field width + size width</li>
        <ol>
          <li>output change code to smaller field width</li>
          <li>translate input to output until input pointer equals lookahead pointer.</li>
        </ol>
      </ol>
      <li>if still requiring present field width then </li>
      <ol>
        <li>reset potential savings.</li>
        <ol>
        </ol>
      </ol>
      <li>if lookahead at end of input</li>
      <ol>
        <li>translate input to output until end of input.</li>
        <li>DONE</li>
      </ol>
    </ol>
    So, we need
    <ol>
      <li>state variables:</li>
      <ol>
        <li>expect size field</li>
        <li>expect value</li>
        <li>(DONE)</li>
      </ol>
      <li>present field size variable</li>
      <li>perhaps some representation of "max field value" of which all ones makes a simple &lt; determination </li>
      <li>two pointers to the input stream, </li>
      <ol>
        <li>the lookahead and </li>
        <li>the last emitted.</li>
      </ol>
      <li>an output stream bit packer</li>
    </ol>
    <hr>
    <h3>Optimal step ups</h3>
    Sometimes a step up will be followed shortly by another step up. If the first step was to the second value we would save the cost of the change of size at the cost of a few extra bits for each channel prior to the second change.<br>
    That means when we need a step up we should record how far up and lookahead for a while longer to see if the step should be greater. That means we have to track costs for a while before applying the new change. <br>
    So, we have to track for a few different step up values how many bits we would be saving before we do the step up.<br>
    <br>
    Example:<br>
    Starting with a long string of 10's we have a cost of 10+4 to shift. <br>
    <table cellspacing="0" cellpadding="3" border="1">
      <tbody>
        <tr>
          <td>bits required</td>
          <td>10</td>
          <td>10</td>
          <td>11</td>
          <td>11</td>
          <td>11</td>
          <td>12</td>
          <td>12</td>
          <td>12</td>
          <td>total</td>
        </tr>
        <tr>
          <td>shift ASAP<br>
          </td>
          <td>10<br>
          </td>
          <td>10<br>
          </td>
          <td>11+14<br>
          </td>
          <td>11<br>
          </td>
          <td>11<br>
          </td>
          <td>12+15<br>
          </td>
          <td>12<br>
          </td>
          <td>12<br>
          </td>
          <td>98</td>
        </tr>
        <tr>
          <td>shift up deferred<br>
          </td>
          <td>10<br>
          </td>
          <td>10<br>
          </td>
          <td>12+14<br>
          </td>
          <td>12<br>
          </td>
          <td>12<br>
          </td>
          <td>12<br>
          </td>
          <td>12<br>
          </td>
          <td>12<br>
          </td>
          <td>86</td>
        </tr>
      </tbody>
    </table>
    <br>
    Deferring the shift netted an improvement of 12 bits.<br>
    So how far forward do we look before doing an upshift? If we don't see another step of 1 up then we can emit our backlog when using the values from the example lookahead count = 2nd shift cost. So for a step up of 1 the new size + 4 is as far as we need to look ahead. If we encounter another step up in that range we can reduce the threshold to newer level* lookahead count &gt; intermediate size +4. <br>
    <br>
    So, we look ahead for step ups and step downs. The step up pending cost is computed as (future_max-past_level)*lookahead distance and is compared against past_level+4. <br>
    We can do this incrementally:<br>
    <ul>
      <li>at each actual step up </li>
      <ul>
        <li>set present size</li>
        <li>set threshold=new value + shift code size (our 4)</li>
        <li>set cost to zero.</li>
      </ul>
      <li>with each lookahead compare new size value to present size, do 3-way branch</li>
      <ul>
        <li>if same do nothing</li>
        <li>if new is greater</li>
        <ul>
          <li>if already considering a step up compare to that size and if greater </li>
          <ul>
            <li>take difference between newest size and pending size and multiply that times lookahead count and add that to cost..</li>
            <li>else just add the difference between it and present size to cost.</li>
          </ul>
          <li>compare cost to upshift threshold.</li>
          <li>if greater (or equal) then actually step up.</li>
        </ul>
        <li>if new is lesser</li>
        <ul>
          <li>if no shiftup is pending do shift down logic</li>
        </ul>
      </ul>
    </ul>
    <p>So we need variables for:</p>
    <ol>
      <li>the cost, </li>
      <li>the threshold, </li>
      <li>the pending upshift</li>
      <li>boolean for pending upshift, but can use 0&nbsp; sentinel value in pending upshift</li>
      <li>&nbsp;the lookahead counter, but can take the difference between lookahead pointer and processed pointer.</li>
    </ol>
    <p><br>
    </p>
    <hr>
    <h3> Stretches of all zeros</h3>
    It is common for spectra to have long sequences of all zeroes. A naive rendering of the encoding would result in zero width fields, and that means no input for the encoder and we no longer do anything. Limiting the field width to &gt;=1 we get data fields which are either zero for zero or one which is our key value for 'new field width', which would greatly expand the encoded length of zero length runs. <br>
    As such we use 2 as the minimum field width, which leaves us with a value in the encoding of field width to indicate some other encoding. We'll use that for 'run of zeroes, following 4 bits is the number of them'. A run of length 0 is another encoding nonsense which we can reinterpret as '&gt; 15, another run length nibble follows'. <br>
    <br>
    To our encoder we add:<br>
    While doing 2 bit fields <br>
    <ol>
      <li>lookahead read input field</li>
      <li>if not zero </li>
      <ol>
        <li>if run length &gt;enough to be worth emitting run length switch code </li>
        <ol>
          <li>emit run length code and content</li>
        </ol>
        <li>else </li>
        <ol>
          <li>emit run length quantity of 2 bits of zeroes (depending upon emitter facility emit a field of width 2*run length, value all zeroes)</li>
        </ol>
        <li>clear run length</li>
        <li>set state to "2 bit fields" and "expecting data"</li>
      </ol>
      <li>if zero increment run length.</li>
      <li>if lookahead at end of input</li>
      <ol>
        <li>emit run length code and content</li>
        <li>DONE</li>
      </ol>
    </ol>
    <hr>
    <h3> Decoder</h3>
    <ol>
      <li>If no more input </li>
      <ol>
        <li>flush any pending run or lookahead range</li>
        <li>DONE</li>
      </ol>
      <li>read field</li>
      <ol>
        <li>if expecting field width </li>
        <ol>
          <li>read 4 bits</li>
          <li>if 0 then set to raw data field width</li>
          <li>if 1 then expect run length </li>
          <li>else set input field width and that we are expecting data</li>
        </ol>
        <li>if expecting data </li>
        <ol>
          <li>read 'field width' bits</li>
          <li>if 'change indicator'(all ones)</li>
          <ol>
            <li>set 'expecting field width'</li>
          </ol>
          <li>else</li>
          <ol>
            <li>emit data</li>
          </ol>
        </ol>
        <li>if expecting run length</li>
        <ol>
          <li>read 4 bits</li>
          <li>if 0 then </li>
          <ol>
            <li>output 16 zeroes and continue to expect run length nibbles.</li>
          </ol>
          <li>else </li>
          <ol>
            <li>output given amount of zeroes</li>
          </ol>
        </ol>
      </ol>
    </ol>
    <br>
    <hr>
    <h3> Predicting compression</h3>
    <p>&nbsp;... via using a spread sheet.</p>
    <p>Load spectrum into a column, spreadsheets don't like wide rows.<br>
      Beside that have a column of "ceil(log2(cell to left))", this is the required field width.<br>
      Beside that have a column of "is&gt;1".<br>
      Beside that have a column of "minus prior", !=0 indicates a potential change of field width</p>
    <p>gcc with -mlzcnt provides <code>unsigned int __builtin_ia32_lzcnt_u32(unsigned int);</code></p>
    <p></p>
    <p><br>
    </p>
  </body>
</html>
